# Generated from /Users/m1n0/dev/soda/soda-sql/soda-library/src/soda/soda/sodacl/antlr/SodaCLAntlr.g4 by ANTLR 4.11.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,65,484,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        1,0,1,0,1,0,1,0,1,0,1,0,3,0,113,8,0,1,1,1,1,1,1,3,1,118,8,1,1,2,
        1,2,1,2,3,2,123,8,2,1,2,1,2,1,3,1,3,1,3,3,3,130,8,3,1,3,1,3,1,4,
        1,4,1,4,3,4,137,8,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,145,8,5,1,5,1,5,
        1,5,1,5,3,5,151,8,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,7,1,8,
        1,8,1,8,1,9,1,9,1,9,3,9,169,8,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,
        3,10,178,8,10,1,10,1,10,1,10,1,10,3,10,184,8,10,1,10,1,10,1,11,1,
        11,1,11,3,11,191,8,11,1,11,1,11,1,11,1,11,3,11,197,8,11,3,11,199,
        8,11,1,11,1,11,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,3,13,
        212,8,13,1,13,3,13,215,8,13,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,
        14,1,14,1,14,3,14,227,8,14,1,15,1,15,1,16,1,16,1,17,1,17,1,17,1,
        18,1,18,1,19,1,19,1,20,1,20,3,20,242,8,20,1,21,1,21,1,22,1,22,1,
        22,1,22,1,22,5,22,251,8,22,10,22,12,22,254,9,22,1,22,1,22,1,23,1,
        23,3,23,260,8,23,1,24,1,24,3,24,264,8,24,1,25,1,25,3,25,268,8,25,
        1,26,1,26,3,26,272,8,26,1,26,1,26,1,26,3,26,277,8,26,1,26,1,26,1,
        26,1,26,1,26,1,26,3,26,285,8,26,1,27,1,27,1,27,1,27,3,27,291,8,27,
        1,27,1,27,1,27,3,27,296,8,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,
        304,8,27,1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,29,1,30,
        1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,4,30,325,8,30,11,30,12,30,
        326,1,30,1,30,1,31,1,31,1,32,1,32,1,33,1,33,1,34,1,34,3,34,339,8,
        34,1,34,3,34,342,8,34,1,34,1,34,3,34,346,8,34,1,35,1,35,1,36,4,36,
        351,8,36,11,36,12,36,352,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,
        1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,5,37,372,8,37,10,37,
        12,37,375,9,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,
        1,37,5,37,388,8,37,10,37,12,37,391,9,37,1,37,1,37,3,37,395,8,37,
        1,38,1,38,1,38,1,38,3,38,401,8,38,1,38,1,38,1,39,1,39,1,40,1,40,
        1,41,1,41,1,41,1,41,1,41,1,41,3,41,415,8,41,1,42,1,42,1,42,1,42,
        1,42,3,42,422,8,42,1,42,1,42,1,43,1,43,1,44,1,44,1,44,1,44,1,44,
        1,44,1,44,1,45,1,45,1,45,1,45,1,45,1,46,1,46,1,46,1,46,1,46,1,46,
        1,46,1,46,1,46,1,46,3,46,450,8,46,1,47,1,47,1,47,1,47,1,47,1,48,
        1,48,1,48,1,48,1,48,1,49,3,49,463,8,49,1,49,1,49,1,50,1,50,1,50,
        1,50,3,50,471,8,50,1,50,3,50,474,8,50,1,50,1,50,3,50,478,8,50,1,
        51,1,51,1,52,1,52,1,52,0,0,53,0,2,4,6,8,10,12,14,16,18,20,22,24,
        26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
        70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,0,8,1,0,
        35,37,2,0,38,38,42,42,2,0,39,39,43,43,1,0,30,32,2,0,50,50,53,53,
        1,0,48,54,1,0,46,47,2,0,35,37,55,58,486,0,112,1,0,0,0,2,117,1,0,
        0,0,4,119,1,0,0,0,6,126,1,0,0,0,8,133,1,0,0,0,10,140,1,0,0,0,12,
        154,1,0,0,0,14,159,1,0,0,0,16,162,1,0,0,0,18,165,1,0,0,0,20,172,
        1,0,0,0,22,190,1,0,0,0,24,202,1,0,0,0,26,206,1,0,0,0,28,226,1,0,
        0,0,30,228,1,0,0,0,32,230,1,0,0,0,34,232,1,0,0,0,36,235,1,0,0,0,
        38,237,1,0,0,0,40,239,1,0,0,0,42,243,1,0,0,0,44,245,1,0,0,0,46,259,
        1,0,0,0,48,263,1,0,0,0,50,267,1,0,0,0,52,271,1,0,0,0,54,286,1,0,
        0,0,56,305,1,0,0,0,58,309,1,0,0,0,60,324,1,0,0,0,62,330,1,0,0,0,
        64,332,1,0,0,0,66,334,1,0,0,0,68,345,1,0,0,0,70,347,1,0,0,0,72,350,
        1,0,0,0,74,394,1,0,0,0,76,396,1,0,0,0,78,404,1,0,0,0,80,406,1,0,
        0,0,82,414,1,0,0,0,84,416,1,0,0,0,86,425,1,0,0,0,88,427,1,0,0,0,
        90,434,1,0,0,0,92,449,1,0,0,0,94,451,1,0,0,0,96,456,1,0,0,0,98,462,
        1,0,0,0,100,477,1,0,0,0,102,479,1,0,0,0,104,481,1,0,0,0,106,113,
        3,16,8,0,107,113,3,20,10,0,108,113,3,22,11,0,109,113,3,74,37,0,110,
        113,3,10,5,0,111,113,3,18,9,0,112,106,1,0,0,0,112,107,1,0,0,0,112,
        108,1,0,0,0,112,109,1,0,0,0,112,110,1,0,0,0,112,111,1,0,0,0,113,
        1,1,0,0,0,114,118,3,6,3,0,115,118,3,4,2,0,116,118,3,8,4,0,117,114,
        1,0,0,0,117,115,1,0,0,0,117,116,1,0,0,0,118,3,1,0,0,0,119,122,5,
        1,0,0,120,121,5,65,0,0,121,123,3,48,24,0,122,120,1,0,0,0,122,123,
        1,0,0,0,123,124,1,0,0,0,124,125,5,0,0,1,125,5,1,0,0,0,126,129,3,
        40,20,0,127,128,5,65,0,0,128,130,3,50,25,0,129,127,1,0,0,0,129,130,
        1,0,0,0,130,131,1,0,0,0,131,132,5,0,0,1,132,7,1,0,0,0,133,136,5,
        2,0,0,134,135,5,65,0,0,135,137,3,48,24,0,136,134,1,0,0,0,136,137,
        1,0,0,0,137,138,1,0,0,0,138,139,5,0,0,1,139,9,1,0,0,0,140,141,5,
        3,0,0,141,142,5,65,0,0,142,144,3,104,52,0,143,145,3,12,6,0,144,143,
        1,0,0,0,144,145,1,0,0,0,145,150,1,0,0,0,146,147,5,65,0,0,147,148,
        5,53,0,0,148,149,5,65,0,0,149,151,3,72,36,0,150,146,1,0,0,0,150,
        151,1,0,0,0,151,152,1,0,0,0,152,153,5,0,0,1,153,11,1,0,0,0,154,155,
        5,65,0,0,155,156,5,4,0,0,156,157,5,65,0,0,157,158,3,104,52,0,158,
        13,1,0,0,0,159,160,5,65,0,0,160,161,5,30,0,0,161,15,1,0,0,0,162,
        163,5,5,0,0,163,164,5,0,0,1,164,17,1,0,0,0,165,168,5,6,0,0,166,167,
        5,65,0,0,167,169,3,104,52,0,168,166,1,0,0,0,168,169,1,0,0,0,169,
        170,1,0,0,0,170,171,5,0,0,1,171,19,1,0,0,0,172,173,5,7,0,0,173,174,
        5,65,0,0,174,177,3,104,52,0,175,176,5,65,0,0,176,178,3,86,43,0,177,
        175,1,0,0,0,177,178,1,0,0,0,178,183,1,0,0,0,179,180,5,65,0,0,180,
        181,5,29,0,0,181,182,5,65,0,0,182,184,3,104,52,0,183,179,1,0,0,0,
        183,184,1,0,0,0,184,185,1,0,0,0,185,186,5,0,0,1,186,21,1,0,0,0,187,
        191,3,26,13,0,188,191,3,36,18,0,189,191,3,38,19,0,190,187,1,0,0,
        0,190,188,1,0,0,0,190,189,1,0,0,0,190,191,1,0,0,0,191,192,1,0,0,
        0,192,198,3,40,20,0,193,196,5,65,0,0,194,197,3,48,24,0,195,197,3,
        24,12,0,196,194,1,0,0,0,196,195,1,0,0,0,197,199,1,0,0,0,198,193,
        1,0,0,0,198,199,1,0,0,0,199,200,1,0,0,0,200,201,5,0,0,1,201,23,1,
        0,0,0,202,203,5,53,0,0,203,204,5,65,0,0,204,205,5,8,0,0,205,25,1,
        0,0,0,206,207,5,33,0,0,207,211,5,65,0,0,208,209,3,28,14,0,209,210,
        5,65,0,0,210,212,1,0,0,0,211,208,1,0,0,0,211,212,1,0,0,0,212,214,
        1,0,0,0,213,215,3,34,17,0,214,213,1,0,0,0,214,215,1,0,0,0,215,216,
        1,0,0,0,216,217,5,25,0,0,217,218,5,65,0,0,218,27,1,0,0,0,219,220,
        3,30,15,0,220,221,5,65,0,0,221,222,5,34,0,0,222,223,5,65,0,0,223,
        224,3,102,51,0,224,227,1,0,0,0,225,227,3,32,16,0,226,219,1,0,0,0,
        226,225,1,0,0,0,227,29,1,0,0,0,228,229,7,0,0,0,229,31,1,0,0,0,230,
        231,5,9,0,0,231,33,1,0,0,0,232,233,5,10,0,0,233,234,5,65,0,0,234,
        35,1,0,0,0,235,236,5,11,0,0,236,37,1,0,0,0,237,238,5,12,0,0,238,
        39,1,0,0,0,239,241,3,42,21,0,240,242,3,44,22,0,241,240,1,0,0,0,241,
        242,1,0,0,0,242,41,1,0,0,0,243,244,3,104,52,0,244,43,1,0,0,0,245,
        246,5,42,0,0,246,252,3,46,23,0,247,248,5,44,0,0,248,249,5,65,0,0,
        249,251,3,46,23,0,250,247,1,0,0,0,251,254,1,0,0,0,252,250,1,0,0,
        0,252,253,1,0,0,0,253,255,1,0,0,0,254,252,1,0,0,0,255,256,5,43,0,
        0,256,45,1,0,0,0,257,260,3,98,49,0,258,260,3,104,52,0,259,257,1,
        0,0,0,259,258,1,0,0,0,260,47,1,0,0,0,261,264,3,56,28,0,262,264,3,
        52,26,0,263,261,1,0,0,0,263,262,1,0,0,0,264,49,1,0,0,0,265,268,3,
        58,29,0,266,268,3,54,27,0,267,265,1,0,0,0,267,266,1,0,0,0,268,51,
        1,0,0,0,269,270,5,28,0,0,270,272,5,65,0,0,271,269,1,0,0,0,271,272,
        1,0,0,0,272,273,1,0,0,0,273,274,5,27,0,0,274,276,5,65,0,0,275,277,
        7,1,0,0,276,275,1,0,0,0,276,277,1,0,0,0,277,278,1,0,0,0,278,279,
        3,68,34,0,279,280,5,65,0,0,280,281,5,26,0,0,281,282,5,65,0,0,282,
        284,3,68,34,0,283,285,7,2,0,0,284,283,1,0,0,0,284,285,1,0,0,0,285,
        53,1,0,0,0,286,287,3,70,35,0,287,290,5,65,0,0,288,289,5,28,0,0,289,
        291,5,65,0,0,290,288,1,0,0,0,290,291,1,0,0,0,291,292,1,0,0,0,292,
        293,5,27,0,0,293,295,5,65,0,0,294,296,7,1,0,0,295,294,1,0,0,0,295,
        296,1,0,0,0,296,297,1,0,0,0,297,298,3,68,34,0,298,299,5,65,0,0,299,
        300,5,26,0,0,300,301,5,65,0,0,301,303,3,68,34,0,302,304,7,2,0,0,
        303,302,1,0,0,0,303,304,1,0,0,0,304,55,1,0,0,0,305,306,3,66,33,0,
        306,307,5,65,0,0,307,308,3,68,34,0,308,57,1,0,0,0,309,310,3,70,35,
        0,310,311,5,65,0,0,311,312,3,66,33,0,312,313,5,65,0,0,313,314,3,
        68,34,0,314,59,1,0,0,0,315,316,3,62,31,0,316,317,5,65,0,0,317,318,
        3,64,32,0,318,319,5,65,0,0,319,320,3,68,34,0,320,321,5,65,0,0,321,
        322,3,64,32,0,322,323,5,65,0,0,323,325,1,0,0,0,324,315,1,0,0,0,325,
        326,1,0,0,0,326,324,1,0,0,0,326,327,1,0,0,0,327,328,1,0,0,0,328,
        329,3,62,31,0,329,61,1,0,0,0,330,331,7,3,0,0,331,63,1,0,0,0,332,
        333,7,4,0,0,333,65,1,0,0,0,334,335,7,5,0,0,335,67,1,0,0,0,336,341,
        3,98,49,0,337,339,5,65,0,0,338,337,1,0,0,0,338,339,1,0,0,0,339,340,
        1,0,0,0,340,342,5,45,0,0,341,338,1,0,0,0,341,342,1,0,0,0,342,346,
        1,0,0,0,343,346,3,72,36,0,344,346,5,57,0,0,345,336,1,0,0,0,345,343,
        1,0,0,0,345,344,1,0,0,0,346,69,1,0,0,0,347,348,5,13,0,0,348,71,1,
        0,0,0,349,351,5,61,0,0,350,349,1,0,0,0,351,352,1,0,0,0,352,350,1,
        0,0,0,352,353,1,0,0,0,353,73,1,0,0,0,354,355,5,14,0,0,355,356,5,
        65,0,0,356,357,3,78,39,0,357,358,5,65,0,0,358,359,3,76,38,0,359,
        360,5,65,0,0,360,361,3,104,52,0,361,362,5,65,0,0,362,363,3,80,40,
        0,363,395,1,0,0,0,364,365,5,14,0,0,365,366,5,65,0,0,366,367,5,42,
        0,0,367,373,3,78,39,0,368,369,5,44,0,0,369,370,5,65,0,0,370,372,
        3,78,39,0,371,368,1,0,0,0,372,375,1,0,0,0,373,371,1,0,0,0,373,374,
        1,0,0,0,374,376,1,0,0,0,375,373,1,0,0,0,376,377,5,43,0,0,377,378,
        5,65,0,0,378,379,3,76,38,0,379,380,5,65,0,0,380,381,3,104,52,0,381,
        382,5,65,0,0,382,383,5,42,0,0,383,389,3,80,40,0,384,385,5,44,0,0,
        385,386,5,65,0,0,386,388,3,80,40,0,387,384,1,0,0,0,388,391,1,0,0,
        0,389,387,1,0,0,0,389,390,1,0,0,0,390,392,1,0,0,0,391,389,1,0,0,
        0,392,393,5,43,0,0,393,395,1,0,0,0,394,354,1,0,0,0,394,364,1,0,0,
        0,395,75,1,0,0,0,396,397,5,15,0,0,397,400,5,65,0,0,398,399,5,28,
        0,0,399,401,5,65,0,0,400,398,1,0,0,0,400,401,1,0,0,0,401,402,1,0,
        0,0,402,403,5,16,0,0,403,77,1,0,0,0,404,405,3,104,52,0,405,79,1,
        0,0,0,406,407,3,104,52,0,407,81,1,0,0,0,408,415,3,84,42,0,409,415,
        3,90,45,0,410,415,3,88,44,0,411,415,3,92,46,0,412,415,3,94,47,0,
        413,415,3,96,48,0,414,408,1,0,0,0,414,409,1,0,0,0,414,410,1,0,0,
        0,414,411,1,0,0,0,414,412,1,0,0,0,414,413,1,0,0,0,415,83,1,0,0,0,
        416,417,5,17,0,0,417,418,5,65,0,0,418,421,3,104,52,0,419,420,5,65,
        0,0,420,422,3,86,43,0,421,419,1,0,0,0,421,422,1,0,0,0,422,423,1,
        0,0,0,423,424,5,0,0,1,424,85,1,0,0,0,425,426,3,104,52,0,426,87,1,
        0,0,0,427,428,5,18,0,0,428,429,5,65,0,0,429,430,3,104,52,0,430,431,
        5,65,0,0,431,432,3,86,43,0,432,433,5,0,0,1,433,89,1,0,0,0,434,435,
        5,19,0,0,435,436,5,65,0,0,436,437,3,104,52,0,437,438,5,0,0,1,438,
        91,1,0,0,0,439,440,5,20,0,0,440,441,5,65,0,0,441,442,3,104,52,0,
        442,443,5,0,0,1,443,450,1,0,0,0,444,445,5,21,0,0,445,446,5,65,0,
        0,446,447,3,104,52,0,447,448,5,0,0,1,448,450,1,0,0,0,449,439,1,0,
        0,0,449,444,1,0,0,0,450,93,1,0,0,0,451,452,5,22,0,0,452,453,5,65,
        0,0,453,454,3,104,52,0,454,455,5,0,0,1,455,95,1,0,0,0,456,457,5,
        23,0,0,457,458,5,65,0,0,458,459,3,104,52,0,459,460,5,0,0,1,460,97,
        1,0,0,0,461,463,7,6,0,0,462,461,1,0,0,0,462,463,1,0,0,0,463,464,
        1,0,0,0,464,465,3,100,50,0,465,99,1,0,0,0,466,478,3,102,51,0,467,
        468,5,60,0,0,468,470,5,24,0,0,469,471,5,60,0,0,470,469,1,0,0,0,470,
        471,1,0,0,0,471,478,1,0,0,0,472,474,5,60,0,0,473,472,1,0,0,0,473,
        474,1,0,0,0,474,475,1,0,0,0,475,476,5,24,0,0,476,478,5,60,0,0,477,
        466,1,0,0,0,477,467,1,0,0,0,477,473,1,0,0,0,478,101,1,0,0,0,479,
        480,5,60,0,0,480,103,1,0,0,0,481,482,7,7,0,0,482,105,1,0,0,0,43,
        112,117,122,129,136,144,150,168,177,183,190,196,198,211,214,226,
        241,252,259,263,267,271,276,284,290,295,303,326,338,341,345,352,
        373,389,394,400,414,421,449,462,470,473,477
    ]

class SodaCLAntlrParser ( Parser ):

    grammarFileName = "SodaCLAntlr.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'rows diff'", "'schema'", "'freshness using'", 
                     "'with'", "'failed rows'", "'group by'", "'row_count same as'", 
                     "'default'", "'same day last week'", "'percent'", "'anomaly score for '", 
                     "'anomaly detection for '", "'diff'", "'values in'", 
                     "'must'", "'exist in'", "'checks for'", "'filter'", 
                     "'configurations for'", "'for each dataset'", "'for each table'", 
                     "'for each column'", "'reconciliation'", "'.'", "'for'", 
                     "'and'", "'between'", "'not'", "'in'", "'warn'", "'fail'", 
                     "'pass'", "'change'", "'last'", "'avg'", "'min'", "'max'", 
                     "'['", "']'", "'{'", "'}'", "'('", "')'", "','", "'%'", 
                     "'+'", "'-'", "'!='", "'<>'", "'<='", "'>='", "'='", 
                     "'<'", "'>'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'d'", "'h'", "'m'", "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "FOR", "AND", "BETWEEN", "NOT", "IN", 
                      "WARN", "FAIL", "PASS", "CHANGE", "LAST", "AVG", "MIN", 
                      "MAX", "SQUARE_LEFT", "SQUARE_RIGHT", "CURLY_LEFT", 
                      "CURLY_RIGHT", "ROUND_LEFT", "ROUND_RIGHT", "COMMA", 
                      "PERCENT", "PLUS", "MINUS", "NOT_EQUAL", "NOT_EQUAL_SQL", 
                      "LTE", "GTE", "EQUAL", "LT", "GT", "IDENTIFIER_DOUBLE_QUOTE", 
                      "IDENTIFIER_BACKTICK", "IDENTIFIER_UNQUOTED", "IDENTIFIER_SQUARE_BRACKETS", 
                      "STRING", "DIGITS", "TIMEUNIT", "DAY", "HOUR", "MINUTE", 
                      "S" ]

    RULE_check = 0
    RULE_reconciliation_check = 1
    RULE_reconciliation_row_diff_check = 2
    RULE_reconciliation_metric_check = 3
    RULE_reconciliation_schema_check = 4
    RULE_freshness_check = 5
    RULE_freshness_variable = 6
    RULE_warn_qualifier = 7
    RULE_failed_rows_check = 8
    RULE_group_by_check = 9
    RULE_row_count_comparison_check = 10
    RULE_metric_check = 11
    RULE_default_anomaly_threshold = 12
    RULE_change_over_time = 13
    RULE_change_over_time_config = 14
    RULE_change_aggregation = 15
    RULE_same_day_last_week = 16
    RULE_percent = 17
    RULE_anomaly_score = 18
    RULE_anomaly_detection = 19
    RULE_metric = 20
    RULE_metric_name = 21
    RULE_metric_args = 22
    RULE_metric_arg = 23
    RULE_threshold = 24
    RULE_reconciliation_threshold = 25
    RULE_between_threshold = 26
    RULE_reconciliation_between_threshold = 27
    RULE_comparator_threshold = 28
    RULE_reconciliation_comparator_threshold = 29
    RULE_zones_threshold = 30
    RULE_outcome = 31
    RULE_zone_comparator = 32
    RULE_comparator = 33
    RULE_threshold_value = 34
    RULE_diff = 35
    RULE_freshness_threshold_value = 36
    RULE_reference_check = 37
    RULE_reference_must_exist = 38
    RULE_source_column_name = 39
    RULE_target_column_name = 40
    RULE_section_header = 41
    RULE_table_checks_header = 42
    RULE_partition_name = 43
    RULE_table_filter_header = 44
    RULE_column_configurations_header = 45
    RULE_checks_for_each_dataset_header = 46
    RULE_checks_for_each_column_header = 47
    RULE_reconciliation_check_header = 48
    RULE_signed_number = 49
    RULE_number = 50
    RULE_integer = 51
    RULE_identifier = 52

    ruleNames =  [ "check", "reconciliation_check", "reconciliation_row_diff_check", 
                   "reconciliation_metric_check", "reconciliation_schema_check", 
                   "freshness_check", "freshness_variable", "warn_qualifier", 
                   "failed_rows_check", "group_by_check", "row_count_comparison_check", 
                   "metric_check", "default_anomaly_threshold", "change_over_time", 
                   "change_over_time_config", "change_aggregation", "same_day_last_week", 
                   "percent", "anomaly_score", "anomaly_detection", "metric", 
                   "metric_name", "metric_args", "metric_arg", "threshold", 
                   "reconciliation_threshold", "between_threshold", "reconciliation_between_threshold", 
                   "comparator_threshold", "reconciliation_comparator_threshold", 
                   "zones_threshold", "outcome", "zone_comparator", "comparator", 
                   "threshold_value", "diff", "freshness_threshold_value", 
                   "reference_check", "reference_must_exist", "source_column_name", 
                   "target_column_name", "section_header", "table_checks_header", 
                   "partition_name", "table_filter_header", "column_configurations_header", 
                   "checks_for_each_dataset_header", "checks_for_each_column_header", 
                   "reconciliation_check_header", "signed_number", "number", 
                   "integer", "identifier" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    FOR=25
    AND=26
    BETWEEN=27
    NOT=28
    IN=29
    WARN=30
    FAIL=31
    PASS=32
    CHANGE=33
    LAST=34
    AVG=35
    MIN=36
    MAX=37
    SQUARE_LEFT=38
    SQUARE_RIGHT=39
    CURLY_LEFT=40
    CURLY_RIGHT=41
    ROUND_LEFT=42
    ROUND_RIGHT=43
    COMMA=44
    PERCENT=45
    PLUS=46
    MINUS=47
    NOT_EQUAL=48
    NOT_EQUAL_SQL=49
    LTE=50
    GTE=51
    EQUAL=52
    LT=53
    GT=54
    IDENTIFIER_DOUBLE_QUOTE=55
    IDENTIFIER_BACKTICK=56
    IDENTIFIER_UNQUOTED=57
    IDENTIFIER_SQUARE_BRACKETS=58
    STRING=59
    DIGITS=60
    TIMEUNIT=61
    DAY=62
    HOUR=63
    MINUTE=64
    S=65

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class CheckContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def failed_rows_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Failed_rows_checkContext,0)


        def row_count_comparison_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Row_count_comparison_checkContext,0)


        def metric_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Metric_checkContext,0)


        def reference_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reference_checkContext,0)


        def freshness_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_checkContext,0)


        def group_by_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Group_by_checkContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheck" ):
                listener.enterCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheck" ):
                listener.exitCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCheck" ):
                return visitor.visitCheck(self)
            else:
                return visitor.visitChildren(self)




    def check(self):

        localctx = SodaCLAntlrParser.CheckContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_check)
        try:
            self.state = 112
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 106
                self.failed_rows_check()
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 2)
                self.state = 107
                self.row_count_comparison_check()
                pass
            elif token in [11, 12, 33, 35, 36, 37, 55, 56, 57, 58]:
                self.enterOuterAlt(localctx, 3)
                self.state = 108
                self.metric_check()
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 4)
                self.state = 109
                self.reference_check()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 5)
                self.state = 110
                self.freshness_check()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 6)
                self.state = 111
                self.group_by_check()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def reconciliation_metric_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reconciliation_metric_checkContext,0)


        def reconciliation_row_diff_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reconciliation_row_diff_checkContext,0)


        def reconciliation_schema_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reconciliation_schema_checkContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_check" ):
                listener.enterReconciliation_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_check" ):
                listener.exitReconciliation_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_check" ):
                return visitor.visitReconciliation_check(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_check(self):

        localctx = SodaCLAntlrParser.Reconciliation_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_reconciliation_check)
        try:
            self.state = 117
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [35, 36, 37, 55, 56, 57, 58]:
                self.enterOuterAlt(localctx, 1)
                self.state = 114
                self.reconciliation_metric_check()
                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 115
                self.reconciliation_row_diff_check()
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 3)
                self.state = 116
                self.reconciliation_schema_check()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_row_diff_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.ThresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_row_diff_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_row_diff_check" ):
                listener.enterReconciliation_row_diff_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_row_diff_check" ):
                listener.exitReconciliation_row_diff_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_row_diff_check" ):
                return visitor.visitReconciliation_row_diff_check(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_row_diff_check(self):

        localctx = SodaCLAntlrParser.Reconciliation_row_diff_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_reconciliation_row_diff_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(SodaCLAntlrParser.T__0)
            self.state = 122
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 120
                self.match(SodaCLAntlrParser.S)
                self.state = 121
                self.threshold()


            self.state = 124
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_metric_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metric(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.MetricContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def reconciliation_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reconciliation_thresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_metric_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_metric_check" ):
                listener.enterReconciliation_metric_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_metric_check" ):
                listener.exitReconciliation_metric_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_metric_check" ):
                return visitor.visitReconciliation_metric_check(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_metric_check(self):

        localctx = SodaCLAntlrParser.Reconciliation_metric_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_reconciliation_metric_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self.metric()
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 127
                self.match(SodaCLAntlrParser.S)
                self.state = 128
                self.reconciliation_threshold()


            self.state = 131
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_schema_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.ThresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_schema_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_schema_check" ):
                listener.enterReconciliation_schema_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_schema_check" ):
                listener.exitReconciliation_schema_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_schema_check" ):
                return visitor.visitReconciliation_schema_check(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_schema_check(self):

        localctx = SodaCLAntlrParser.Reconciliation_schema_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_reconciliation_schema_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.match(SodaCLAntlrParser.T__1)
            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 134
                self.match(SodaCLAntlrParser.S)
                self.state = 135
                self.threshold()


            self.state = 138
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Freshness_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def freshness_variable(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_variableContext,0)


        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def freshness_threshold_value(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_threshold_valueContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_freshness_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFreshness_check" ):
                listener.enterFreshness_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFreshness_check" ):
                listener.exitFreshness_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFreshness_check" ):
                return visitor.visitFreshness_check(self)
            else:
                return visitor.visitChildren(self)




    def freshness_check(self):

        localctx = SodaCLAntlrParser.Freshness_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_freshness_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(SodaCLAntlrParser.T__2)
            self.state = 141
            self.match(SodaCLAntlrParser.S)
            self.state = 142
            self.identifier()
            self.state = 144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 143
                self.freshness_variable()


            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 146
                self.match(SodaCLAntlrParser.S)
                self.state = 147
                self.match(SodaCLAntlrParser.LT)
                self.state = 148
                self.match(SodaCLAntlrParser.S)
                self.state = 149
                self.freshness_threshold_value()


            self.state = 152
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Freshness_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_freshness_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFreshness_variable" ):
                listener.enterFreshness_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFreshness_variable" ):
                listener.exitFreshness_variable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFreshness_variable" ):
                return visitor.visitFreshness_variable(self)
            else:
                return visitor.visitChildren(self)




    def freshness_variable(self):

        localctx = SodaCLAntlrParser.Freshness_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_freshness_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(SodaCLAntlrParser.S)
            self.state = 155
            self.match(SodaCLAntlrParser.T__3)
            self.state = 156
            self.match(SodaCLAntlrParser.S)
            self.state = 157
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Warn_qualifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def WARN(self):
            return self.getToken(SodaCLAntlrParser.WARN, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_warn_qualifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWarn_qualifier" ):
                listener.enterWarn_qualifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWarn_qualifier" ):
                listener.exitWarn_qualifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWarn_qualifier" ):
                return visitor.visitWarn_qualifier(self)
            else:
                return visitor.visitChildren(self)




    def warn_qualifier(self):

        localctx = SodaCLAntlrParser.Warn_qualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_warn_qualifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            self.match(SodaCLAntlrParser.S)
            self.state = 160
            self.match(SodaCLAntlrParser.WARN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Failed_rows_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_failed_rows_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFailed_rows_check" ):
                listener.enterFailed_rows_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFailed_rows_check" ):
                listener.exitFailed_rows_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFailed_rows_check" ):
                return visitor.visitFailed_rows_check(self)
            else:
                return visitor.visitChildren(self)




    def failed_rows_check(self):

        localctx = SodaCLAntlrParser.Failed_rows_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_failed_rows_check)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.match(SodaCLAntlrParser.T__4)
            self.state = 163
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_by_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_group_by_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_by_check" ):
                listener.enterGroup_by_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_by_check" ):
                listener.exitGroup_by_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroup_by_check" ):
                return visitor.visitGroup_by_check(self)
            else:
                return visitor.visitChildren(self)




    def group_by_check(self):

        localctx = SodaCLAntlrParser.Group_by_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_group_by_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(SodaCLAntlrParser.T__5)
            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 166
                self.match(SodaCLAntlrParser.S)
                self.state = 167
                self.identifier()


            self.state = 170
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Row_count_comparison_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,i)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def partition_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Partition_nameContext,0)


        def IN(self):
            return self.getToken(SodaCLAntlrParser.IN, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_row_count_comparison_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRow_count_comparison_check" ):
                listener.enterRow_count_comparison_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRow_count_comparison_check" ):
                listener.exitRow_count_comparison_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRow_count_comparison_check" ):
                return visitor.visitRow_count_comparison_check(self)
            else:
                return visitor.visitChildren(self)




    def row_count_comparison_check(self):

        localctx = SodaCLAntlrParser.Row_count_comparison_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_row_count_comparison_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(SodaCLAntlrParser.T__6)
            self.state = 173
            self.match(SodaCLAntlrParser.S)
            self.state = 174
            self.identifier()
            self.state = 177
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 175
                self.match(SodaCLAntlrParser.S)
                self.state = 176
                self.partition_name()


            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 179
                self.match(SodaCLAntlrParser.S)
                self.state = 180
                self.match(SodaCLAntlrParser.IN)
                self.state = 181
                self.match(SodaCLAntlrParser.S)
                self.state = 182
                self.identifier()


            self.state = 185
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metric(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.MetricContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def change_over_time(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Change_over_timeContext,0)


        def anomaly_score(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Anomaly_scoreContext,0)


        def anomaly_detection(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Anomaly_detectionContext,0)


        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.ThresholdContext,0)


        def default_anomaly_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Default_anomaly_thresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_check" ):
                listener.enterMetric_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_check" ):
                listener.exitMetric_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_check" ):
                return visitor.visitMetric_check(self)
            else:
                return visitor.visitChildren(self)




    def metric_check(self):

        localctx = SodaCLAntlrParser.Metric_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_metric_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [33]:
                self.state = 187
                self.change_over_time()
                pass
            elif token in [11]:
                self.state = 188
                self.anomaly_score()
                pass
            elif token in [12]:
                self.state = 189
                self.anomaly_detection()
                pass
            elif token in [35, 36, 37, 55, 56, 57, 58]:
                pass
            else:
                pass
            self.state = 192
            self.metric()
            self.state = 198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 193
                self.match(SodaCLAntlrParser.S)
                self.state = 196
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                if la_ == 1:
                    self.state = 194
                    self.threshold()
                    pass

                elif la_ == 2:
                    self.state = 195
                    self.default_anomaly_threshold()
                    pass




            self.state = 200
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_anomaly_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_default_anomaly_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault_anomaly_threshold" ):
                listener.enterDefault_anomaly_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault_anomaly_threshold" ):
                listener.exitDefault_anomaly_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_anomaly_threshold" ):
                return visitor.visitDefault_anomaly_threshold(self)
            else:
                return visitor.visitChildren(self)




    def default_anomaly_threshold(self):

        localctx = SodaCLAntlrParser.Default_anomaly_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_default_anomaly_threshold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(SodaCLAntlrParser.LT)
            self.state = 203
            self.match(SodaCLAntlrParser.S)
            self.state = 204
            self.match(SodaCLAntlrParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Change_over_timeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHANGE(self):
            return self.getToken(SodaCLAntlrParser.CHANGE, 0)

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def FOR(self):
            return self.getToken(SodaCLAntlrParser.FOR, 0)

        def change_over_time_config(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Change_over_time_configContext,0)


        def percent(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.PercentContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_change_over_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange_over_time" ):
                listener.enterChange_over_time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange_over_time" ):
                listener.exitChange_over_time(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange_over_time" ):
                return visitor.visitChange_over_time(self)
            else:
                return visitor.visitChildren(self)




    def change_over_time(self):

        localctx = SodaCLAntlrParser.Change_over_timeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_change_over_time)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(SodaCLAntlrParser.CHANGE)
            self.state = 207
            self.match(SodaCLAntlrParser.S)
            self.state = 211
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3f) == 0 and ((1 << _la) & 240518169088) != 0:
                self.state = 208
                self.change_over_time_config()
                self.state = 209
                self.match(SodaCLAntlrParser.S)


            self.state = 214
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 213
                self.percent()


            self.state = 216
            self.match(SodaCLAntlrParser.FOR)
            self.state = 217
            self.match(SodaCLAntlrParser.S)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Change_over_time_configContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change_aggregation(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Change_aggregationContext,0)


        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def LAST(self):
            return self.getToken(SodaCLAntlrParser.LAST, 0)

        def integer(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IntegerContext,0)


        def same_day_last_week(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Same_day_last_weekContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_change_over_time_config

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange_over_time_config" ):
                listener.enterChange_over_time_config(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange_over_time_config" ):
                listener.exitChange_over_time_config(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange_over_time_config" ):
                return visitor.visitChange_over_time_config(self)
            else:
                return visitor.visitChildren(self)




    def change_over_time_config(self):

        localctx = SodaCLAntlrParser.Change_over_time_configContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_change_over_time_config)
        try:
            self.state = 226
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [35, 36, 37]:
                self.enterOuterAlt(localctx, 1)
                self.state = 219
                self.change_aggregation()
                self.state = 220
                self.match(SodaCLAntlrParser.S)
                self.state = 221
                self.match(SodaCLAntlrParser.LAST)
                self.state = 222
                self.match(SodaCLAntlrParser.S)
                self.state = 223
                self.integer()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 225
                self.same_day_last_week()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Change_aggregationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(SodaCLAntlrParser.AVG, 0)

        def MIN(self):
            return self.getToken(SodaCLAntlrParser.MIN, 0)

        def MAX(self):
            return self.getToken(SodaCLAntlrParser.MAX, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_change_aggregation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange_aggregation" ):
                listener.enterChange_aggregation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange_aggregation" ):
                listener.exitChange_aggregation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange_aggregation" ):
                return visitor.visitChange_aggregation(self)
            else:
                return visitor.visitChildren(self)




    def change_aggregation(self):

        localctx = SodaCLAntlrParser.Change_aggregationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_change_aggregation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 240518168576) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Same_day_last_weekContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_same_day_last_week

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSame_day_last_week" ):
                listener.enterSame_day_last_week(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSame_day_last_week" ):
                listener.exitSame_day_last_week(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSame_day_last_week" ):
                return visitor.visitSame_day_last_week(self)
            else:
                return visitor.visitChildren(self)




    def same_day_last_week(self):

        localctx = SodaCLAntlrParser.Same_day_last_weekContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_same_day_last_week)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(SodaCLAntlrParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_percent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercent" ):
                listener.enterPercent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercent" ):
                listener.exitPercent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercent" ):
                return visitor.visitPercent(self)
            else:
                return visitor.visitChildren(self)




    def percent(self):

        localctx = SodaCLAntlrParser.PercentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_percent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(SodaCLAntlrParser.T__9)
            self.state = 233
            self.match(SodaCLAntlrParser.S)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Anomaly_scoreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_anomaly_score

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnomaly_score" ):
                listener.enterAnomaly_score(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnomaly_score" ):
                listener.exitAnomaly_score(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnomaly_score" ):
                return visitor.visitAnomaly_score(self)
            else:
                return visitor.visitChildren(self)




    def anomaly_score(self):

        localctx = SodaCLAntlrParser.Anomaly_scoreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_anomaly_score)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.match(SodaCLAntlrParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Anomaly_detectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_anomaly_detection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnomaly_detection" ):
                listener.enterAnomaly_detection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnomaly_detection" ):
                listener.exitAnomaly_detection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnomaly_detection" ):
                return visitor.visitAnomaly_detection(self)
            else:
                return visitor.visitChildren(self)




    def anomaly_detection(self):

        localctx = SodaCLAntlrParser.Anomaly_detectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_anomaly_detection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(SodaCLAntlrParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetricContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metric_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Metric_nameContext,0)


        def metric_args(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Metric_argsContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric" ):
                listener.enterMetric(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric" ):
                listener.exitMetric(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric" ):
                return visitor.visitMetric(self)
            else:
                return visitor.visitChildren(self)




    def metric(self):

        localctx = SodaCLAntlrParser.MetricContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_metric)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.metric_name()
            self.state = 241
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 240
                self.metric_args()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_name" ):
                listener.enterMetric_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_name" ):
                listener.exitMetric_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_name" ):
                return visitor.visitMetric_name(self)
            else:
                return visitor.visitChildren(self)




    def metric_name(self):

        localctx = SodaCLAntlrParser.Metric_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_metric_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_argsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_LEFT, 0)

        def metric_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Metric_argContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Metric_argContext,i)


        def ROUND_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_RIGHT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.COMMA)
            else:
                return self.getToken(SodaCLAntlrParser.COMMA, i)

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_args" ):
                listener.enterMetric_args(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_args" ):
                listener.exitMetric_args(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_args" ):
                return visitor.visitMetric_args(self)
            else:
                return visitor.visitChildren(self)




    def metric_args(self):

        localctx = SodaCLAntlrParser.Metric_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_metric_args)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.match(SodaCLAntlrParser.ROUND_LEFT)
            self.state = 246
            self.metric_arg()
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 247
                self.match(SodaCLAntlrParser.COMMA)
                self.state = 248
                self.match(SodaCLAntlrParser.S)
                self.state = 249
                self.metric_arg()
                self.state = 254
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 255
            self.match(SodaCLAntlrParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_argContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_number(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Signed_numberContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_arg" ):
                listener.enterMetric_arg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_arg" ):
                listener.exitMetric_arg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_arg" ):
                return visitor.visitMetric_arg(self)
            else:
                return visitor.visitChildren(self)




    def metric_arg(self):

        localctx = SodaCLAntlrParser.Metric_argContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_metric_arg)
        try:
            self.state = 259
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [24, 46, 47, 60]:
                self.enterOuterAlt(localctx, 1)
                self.state = 257
                self.signed_number()
                pass
            elif token in [35, 36, 37, 55, 56, 57, 58]:
                self.enterOuterAlt(localctx, 2)
                self.state = 258
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparator_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Comparator_thresholdContext,0)


        def between_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Between_thresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThreshold" ):
                listener.enterThreshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThreshold" ):
                listener.exitThreshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThreshold" ):
                return visitor.visitThreshold(self)
            else:
                return visitor.visitChildren(self)




    def threshold(self):

        localctx = SodaCLAntlrParser.ThresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_threshold)
        try:
            self.state = 263
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48, 49, 50, 51, 52, 53, 54]:
                self.enterOuterAlt(localctx, 1)
                self.state = 261
                self.comparator_threshold()
                pass
            elif token in [27, 28]:
                self.enterOuterAlt(localctx, 2)
                self.state = 262
                self.between_threshold()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def reconciliation_comparator_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reconciliation_comparator_thresholdContext,0)


        def reconciliation_between_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reconciliation_between_thresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_threshold" ):
                listener.enterReconciliation_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_threshold" ):
                listener.exitReconciliation_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_threshold" ):
                return visitor.visitReconciliation_threshold(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_threshold(self):

        localctx = SodaCLAntlrParser.Reconciliation_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_reconciliation_threshold)
        try:
            self.state = 267
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 265
                self.reconciliation_comparator_threshold()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 266
                self.reconciliation_between_threshold()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Between_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BETWEEN(self):
            return self.getToken(SodaCLAntlrParser.BETWEEN, 0)

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def threshold_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Threshold_valueContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,i)


        def AND(self):
            return self.getToken(SodaCLAntlrParser.AND, 0)

        def NOT(self):
            return self.getToken(SodaCLAntlrParser.NOT, 0)

        def SQUARE_LEFT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_LEFT, 0)

        def ROUND_LEFT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_LEFT, 0)

        def SQUARE_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_RIGHT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_RIGHT, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_between_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBetween_threshold" ):
                listener.enterBetween_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBetween_threshold" ):
                listener.exitBetween_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBetween_threshold" ):
                return visitor.visitBetween_threshold(self)
            else:
                return visitor.visitChildren(self)




    def between_threshold(self):

        localctx = SodaCLAntlrParser.Between_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_between_threshold)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 269
                self.match(SodaCLAntlrParser.NOT)
                self.state = 270
                self.match(SodaCLAntlrParser.S)


            self.state = 273
            self.match(SodaCLAntlrParser.BETWEEN)
            self.state = 274
            self.match(SodaCLAntlrParser.S)
            self.state = 276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38 or _la==42:
                self.state = 275
                _la = self._input.LA(1)
                if not(_la==38 or _la==42):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 278
            self.threshold_value()
            self.state = 279
            self.match(SodaCLAntlrParser.S)
            self.state = 280
            self.match(SodaCLAntlrParser.AND)
            self.state = 281
            self.match(SodaCLAntlrParser.S)
            self.state = 282
            self.threshold_value()
            self.state = 284
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39 or _la==43:
                self.state = 283
                _la = self._input.LA(1)
                if not(_la==39 or _la==43):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_between_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def diff(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.DiffContext,0)


        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def BETWEEN(self):
            return self.getToken(SodaCLAntlrParser.BETWEEN, 0)

        def threshold_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Threshold_valueContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,i)


        def AND(self):
            return self.getToken(SodaCLAntlrParser.AND, 0)

        def NOT(self):
            return self.getToken(SodaCLAntlrParser.NOT, 0)

        def SQUARE_LEFT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_LEFT, 0)

        def ROUND_LEFT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_LEFT, 0)

        def SQUARE_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_RIGHT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_RIGHT, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_between_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_between_threshold" ):
                listener.enterReconciliation_between_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_between_threshold" ):
                listener.exitReconciliation_between_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_between_threshold" ):
                return visitor.visitReconciliation_between_threshold(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_between_threshold(self):

        localctx = SodaCLAntlrParser.Reconciliation_between_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_reconciliation_between_threshold)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.diff()
            self.state = 287
            self.match(SodaCLAntlrParser.S)
            self.state = 290
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 288
                self.match(SodaCLAntlrParser.NOT)
                self.state = 289
                self.match(SodaCLAntlrParser.S)


            self.state = 292
            self.match(SodaCLAntlrParser.BETWEEN)
            self.state = 293
            self.match(SodaCLAntlrParser.S)
            self.state = 295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38 or _la==42:
                self.state = 294
                _la = self._input.LA(1)
                if not(_la==38 or _la==42):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 297
            self.threshold_value()
            self.state = 298
            self.match(SodaCLAntlrParser.S)
            self.state = 299
            self.match(SodaCLAntlrParser.AND)
            self.state = 300
            self.match(SodaCLAntlrParser.S)
            self.state = 301
            self.threshold_value()
            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39 or _la==43:
                self.state = 302
                _la = self._input.LA(1)
                if not(_la==39 or _la==43):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comparator_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparator(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.ComparatorContext,0)


        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def threshold_value(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_comparator_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator_threshold" ):
                listener.enterComparator_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator_threshold" ):
                listener.exitComparator_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator_threshold" ):
                return visitor.visitComparator_threshold(self)
            else:
                return visitor.visitChildren(self)




    def comparator_threshold(self):

        localctx = SodaCLAntlrParser.Comparator_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_comparator_threshold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.comparator()
            self.state = 306
            self.match(SodaCLAntlrParser.S)
            self.state = 307
            self.threshold_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_comparator_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def diff(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.DiffContext,0)


        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def comparator(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.ComparatorContext,0)


        def threshold_value(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_comparator_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_comparator_threshold" ):
                listener.enterReconciliation_comparator_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_comparator_threshold" ):
                listener.exitReconciliation_comparator_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_comparator_threshold" ):
                return visitor.visitReconciliation_comparator_threshold(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_comparator_threshold(self):

        localctx = SodaCLAntlrParser.Reconciliation_comparator_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_reconciliation_comparator_threshold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.diff()
            self.state = 310
            self.match(SodaCLAntlrParser.S)
            self.state = 311
            self.comparator()
            self.state = 312
            self.match(SodaCLAntlrParser.S)
            self.state = 313
            self.threshold_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Zones_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def outcome(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.OutcomeContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.OutcomeContext,i)


        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def zone_comparator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Zone_comparatorContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Zone_comparatorContext,i)


        def threshold_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Threshold_valueContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,i)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_zones_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZones_threshold" ):
                listener.enterZones_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZones_threshold" ):
                listener.exitZones_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZones_threshold" ):
                return visitor.visitZones_threshold(self)
            else:
                return visitor.visitChildren(self)




    def zones_threshold(self):

        localctx = SodaCLAntlrParser.Zones_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_zones_threshold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 315
                    self.outcome()
                    self.state = 316
                    self.match(SodaCLAntlrParser.S)
                    self.state = 317
                    self.zone_comparator()
                    self.state = 318
                    self.match(SodaCLAntlrParser.S)
                    self.state = 319
                    self.threshold_value()
                    self.state = 320
                    self.match(SodaCLAntlrParser.S)
                    self.state = 321
                    self.zone_comparator()
                    self.state = 322
                    self.match(SodaCLAntlrParser.S)

                else:
                    raise NoViableAltException(self)
                self.state = 326 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

            self.state = 328
            self.outcome()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutcomeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WARN(self):
            return self.getToken(SodaCLAntlrParser.WARN, 0)

        def FAIL(self):
            return self.getToken(SodaCLAntlrParser.FAIL, 0)

        def PASS(self):
            return self.getToken(SodaCLAntlrParser.PASS, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_outcome

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutcome" ):
                listener.enterOutcome(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutcome" ):
                listener.exitOutcome(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutcome" ):
                return visitor.visitOutcome(self)
            else:
                return visitor.visitChildren(self)




    def outcome(self):

        localctx = SodaCLAntlrParser.OutcomeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_outcome)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 7516192768) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Zone_comparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def LTE(self):
            return self.getToken(SodaCLAntlrParser.LTE, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_zone_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZone_comparator" ):
                listener.enterZone_comparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZone_comparator" ):
                listener.exitZone_comparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZone_comparator" ):
                return visitor.visitZone_comparator(self)
            else:
                return visitor.visitChildren(self)




    def zone_comparator(self):

        localctx = SodaCLAntlrParser.Zone_comparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_zone_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            _la = self._input.LA(1)
            if not(_la==50 or _la==53):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def LTE(self):
            return self.getToken(SodaCLAntlrParser.LTE, 0)

        def EQUAL(self):
            return self.getToken(SodaCLAntlrParser.EQUAL, 0)

        def GTE(self):
            return self.getToken(SodaCLAntlrParser.GTE, 0)

        def GT(self):
            return self.getToken(SodaCLAntlrParser.GT, 0)

        def NOT_EQUAL(self):
            return self.getToken(SodaCLAntlrParser.NOT_EQUAL, 0)

        def NOT_EQUAL_SQL(self):
            return self.getToken(SodaCLAntlrParser.NOT_EQUAL_SQL, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = SodaCLAntlrParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 35747322042253312) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Threshold_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_number(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Signed_numberContext,0)


        def PERCENT(self):
            return self.getToken(SodaCLAntlrParser.PERCENT, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def freshness_threshold_value(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_threshold_valueContext,0)


        def IDENTIFIER_UNQUOTED(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_UNQUOTED, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_threshold_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThreshold_value" ):
                listener.enterThreshold_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThreshold_value" ):
                listener.exitThreshold_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThreshold_value" ):
                return visitor.visitThreshold_value(self)
            else:
                return visitor.visitChildren(self)




    def threshold_value(self):

        localctx = SodaCLAntlrParser.Threshold_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_threshold_value)
        self._la = 0 # Token type
        try:
            self.state = 345
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [24, 46, 47, 60]:
                self.enterOuterAlt(localctx, 1)
                self.state = 336
                self.signed_number()
                self.state = 341
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
                if la_ == 1:
                    self.state = 338
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==65:
                        self.state = 337
                        self.match(SodaCLAntlrParser.S)


                    self.state = 340
                    self.match(SodaCLAntlrParser.PERCENT)


                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 2)
                self.state = 343
                self.freshness_threshold_value()
                pass
            elif token in [57]:
                self.enterOuterAlt(localctx, 3)
                self.state = 344
                self.match(SodaCLAntlrParser.IDENTIFIER_UNQUOTED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DiffContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_diff

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiff" ):
                listener.enterDiff(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiff" ):
                listener.exitDiff(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiff" ):
                return visitor.visitDiff(self)
            else:
                return visitor.visitChildren(self)




    def diff(self):

        localctx = SodaCLAntlrParser.DiffContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_diff)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            self.match(SodaCLAntlrParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Freshness_threshold_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIMEUNIT(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.TIMEUNIT)
            else:
                return self.getToken(SodaCLAntlrParser.TIMEUNIT, i)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_freshness_threshold_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFreshness_threshold_value" ):
                listener.enterFreshness_threshold_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFreshness_threshold_value" ):
                listener.exitFreshness_threshold_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFreshness_threshold_value" ):
                return visitor.visitFreshness_threshold_value(self)
            else:
                return visitor.visitChildren(self)




    def freshness_threshold_value(self):

        localctx = SodaCLAntlrParser.Freshness_threshold_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_freshness_threshold_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 349
                self.match(SodaCLAntlrParser.TIMEUNIT)
                self.state = 352 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==61):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reference_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def source_column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Source_column_nameContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Source_column_nameContext,i)


        def reference_must_exist(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reference_must_existContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def target_column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Target_column_nameContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Target_column_nameContext,i)


        def ROUND_LEFT(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.ROUND_LEFT)
            else:
                return self.getToken(SodaCLAntlrParser.ROUND_LEFT, i)

        def ROUND_RIGHT(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.ROUND_RIGHT)
            else:
                return self.getToken(SodaCLAntlrParser.ROUND_RIGHT, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.COMMA)
            else:
                return self.getToken(SodaCLAntlrParser.COMMA, i)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reference_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReference_check" ):
                listener.enterReference_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReference_check" ):
                listener.exitReference_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReference_check" ):
                return visitor.visitReference_check(self)
            else:
                return visitor.visitChildren(self)




    def reference_check(self):

        localctx = SodaCLAntlrParser.Reference_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_reference_check)
        self._la = 0 # Token type
        try:
            self.state = 394
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 354
                self.match(SodaCLAntlrParser.T__13)
                self.state = 355
                self.match(SodaCLAntlrParser.S)
                self.state = 356
                self.source_column_name()
                self.state = 357
                self.match(SodaCLAntlrParser.S)
                self.state = 358
                self.reference_must_exist()
                self.state = 359
                self.match(SodaCLAntlrParser.S)
                self.state = 360
                self.identifier()
                self.state = 361
                self.match(SodaCLAntlrParser.S)
                self.state = 362
                self.target_column_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 364
                self.match(SodaCLAntlrParser.T__13)
                self.state = 365
                self.match(SodaCLAntlrParser.S)
                self.state = 366
                self.match(SodaCLAntlrParser.ROUND_LEFT)
                self.state = 367
                self.source_column_name()
                self.state = 373
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==44:
                    self.state = 368
                    self.match(SodaCLAntlrParser.COMMA)
                    self.state = 369
                    self.match(SodaCLAntlrParser.S)
                    self.state = 370
                    self.source_column_name()
                    self.state = 375
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 376
                self.match(SodaCLAntlrParser.ROUND_RIGHT)
                self.state = 377
                self.match(SodaCLAntlrParser.S)
                self.state = 378
                self.reference_must_exist()
                self.state = 379
                self.match(SodaCLAntlrParser.S)
                self.state = 380
                self.identifier()
                self.state = 381
                self.match(SodaCLAntlrParser.S)
                self.state = 382
                self.match(SodaCLAntlrParser.ROUND_LEFT)
                self.state = 383
                self.target_column_name()
                self.state = 389
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==44:
                    self.state = 384
                    self.match(SodaCLAntlrParser.COMMA)
                    self.state = 385
                    self.match(SodaCLAntlrParser.S)
                    self.state = 386
                    self.target_column_name()
                    self.state = 391
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 392
                self.match(SodaCLAntlrParser.ROUND_RIGHT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reference_must_existContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def NOT(self):
            return self.getToken(SodaCLAntlrParser.NOT, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reference_must_exist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReference_must_exist" ):
                listener.enterReference_must_exist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReference_must_exist" ):
                listener.exitReference_must_exist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReference_must_exist" ):
                return visitor.visitReference_must_exist(self)
            else:
                return visitor.visitChildren(self)




    def reference_must_exist(self):

        localctx = SodaCLAntlrParser.Reference_must_existContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_reference_must_exist)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.match(SodaCLAntlrParser.T__14)
            self.state = 397
            self.match(SodaCLAntlrParser.S)
            self.state = 400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 398
                self.match(SodaCLAntlrParser.NOT)
                self.state = 399
                self.match(SodaCLAntlrParser.S)


            self.state = 402
            self.match(SodaCLAntlrParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Source_column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_source_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSource_column_name" ):
                listener.enterSource_column_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSource_column_name" ):
                listener.exitSource_column_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_column_name" ):
                return visitor.visitSource_column_name(self)
            else:
                return visitor.visitChildren(self)




    def source_column_name(self):

        localctx = SodaCLAntlrParser.Source_column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_source_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 404
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Target_column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_target_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget_column_name" ):
                listener.enterTarget_column_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget_column_name" ):
                listener.exitTarget_column_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTarget_column_name" ):
                return visitor.visitTarget_column_name(self)
            else:
                return visitor.visitChildren(self)




    def target_column_name(self):

        localctx = SodaCLAntlrParser.Target_column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_target_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Section_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_checks_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Table_checks_headerContext,0)


        def column_configurations_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Column_configurations_headerContext,0)


        def table_filter_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Table_filter_headerContext,0)


        def checks_for_each_dataset_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Checks_for_each_dataset_headerContext,0)


        def checks_for_each_column_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Checks_for_each_column_headerContext,0)


        def reconciliation_check_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reconciliation_check_headerContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_section_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSection_header" ):
                listener.enterSection_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSection_header" ):
                listener.exitSection_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSection_header" ):
                return visitor.visitSection_header(self)
            else:
                return visitor.visitChildren(self)




    def section_header(self):

        localctx = SodaCLAntlrParser.Section_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_section_header)
        try:
            self.state = 414
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 408
                self.table_checks_header()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 409
                self.column_configurations_header()
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 3)
                self.state = 410
                self.table_filter_header()
                pass
            elif token in [20, 21]:
                self.enterOuterAlt(localctx, 4)
                self.state = 411
                self.checks_for_each_dataset_header()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 5)
                self.state = 412
                self.checks_for_each_column_header()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 6)
                self.state = 413
                self.reconciliation_check_header()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_checks_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def partition_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Partition_nameContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_table_checks_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_checks_header" ):
                listener.enterTable_checks_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_checks_header" ):
                listener.exitTable_checks_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_checks_header" ):
                return visitor.visitTable_checks_header(self)
            else:
                return visitor.visitChildren(self)




    def table_checks_header(self):

        localctx = SodaCLAntlrParser.Table_checks_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_table_checks_header)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            self.match(SodaCLAntlrParser.T__16)
            self.state = 417
            self.match(SodaCLAntlrParser.S)
            self.state = 418
            self.identifier()
            self.state = 421
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 419
                self.match(SodaCLAntlrParser.S)
                self.state = 420
                self.partition_name()


            self.state = 423
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_partition_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_name" ):
                listener.enterPartition_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_name" ):
                listener.exitPartition_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartition_name" ):
                return visitor.visitPartition_name(self)
            else:
                return visitor.visitChildren(self)




    def partition_name(self):

        localctx = SodaCLAntlrParser.Partition_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_partition_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 425
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_filter_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def partition_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Partition_nameContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_table_filter_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_filter_header" ):
                listener.enterTable_filter_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_filter_header" ):
                listener.exitTable_filter_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_filter_header" ):
                return visitor.visitTable_filter_header(self)
            else:
                return visitor.visitChildren(self)




    def table_filter_header(self):

        localctx = SodaCLAntlrParser.Table_filter_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_table_filter_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 427
            self.match(SodaCLAntlrParser.T__17)
            self.state = 428
            self.match(SodaCLAntlrParser.S)
            self.state = 429
            self.identifier()
            self.state = 430
            self.match(SodaCLAntlrParser.S)
            self.state = 431
            self.partition_name()
            self.state = 432
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_configurations_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_column_configurations_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_configurations_header" ):
                listener.enterColumn_configurations_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_configurations_header" ):
                listener.exitColumn_configurations_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_configurations_header" ):
                return visitor.visitColumn_configurations_header(self)
            else:
                return visitor.visitChildren(self)




    def column_configurations_header(self):

        localctx = SodaCLAntlrParser.Column_configurations_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_column_configurations_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self.match(SodaCLAntlrParser.T__18)
            self.state = 435
            self.match(SodaCLAntlrParser.S)
            self.state = 436
            self.identifier()
            self.state = 437
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Checks_for_each_dataset_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_checks_for_each_dataset_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChecks_for_each_dataset_header" ):
                listener.enterChecks_for_each_dataset_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChecks_for_each_dataset_header" ):
                listener.exitChecks_for_each_dataset_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChecks_for_each_dataset_header" ):
                return visitor.visitChecks_for_each_dataset_header(self)
            else:
                return visitor.visitChildren(self)




    def checks_for_each_dataset_header(self):

        localctx = SodaCLAntlrParser.Checks_for_each_dataset_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_checks_for_each_dataset_header)
        try:
            self.state = 449
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20]:
                self.enterOuterAlt(localctx, 1)
                self.state = 439
                self.match(SodaCLAntlrParser.T__19)
                self.state = 440
                self.match(SodaCLAntlrParser.S)
                self.state = 441
                self.identifier()
                self.state = 442
                self.match(SodaCLAntlrParser.EOF)
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 2)
                self.state = 444
                self.match(SodaCLAntlrParser.T__20)
                self.state = 445
                self.match(SodaCLAntlrParser.S)
                self.state = 446
                self.identifier()
                self.state = 447
                self.match(SodaCLAntlrParser.EOF)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Checks_for_each_column_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_checks_for_each_column_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChecks_for_each_column_header" ):
                listener.enterChecks_for_each_column_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChecks_for_each_column_header" ):
                listener.exitChecks_for_each_column_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChecks_for_each_column_header" ):
                return visitor.visitChecks_for_each_column_header(self)
            else:
                return visitor.visitChildren(self)




    def checks_for_each_column_header(self):

        localctx = SodaCLAntlrParser.Checks_for_each_column_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_checks_for_each_column_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(SodaCLAntlrParser.T__21)
            self.state = 452
            self.match(SodaCLAntlrParser.S)
            self.state = 453
            self.identifier()
            self.state = 454
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reconciliation_check_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reconciliation_check_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReconciliation_check_header" ):
                listener.enterReconciliation_check_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReconciliation_check_header" ):
                listener.exitReconciliation_check_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReconciliation_check_header" ):
                return visitor.visitReconciliation_check_header(self)
            else:
                return visitor.visitChildren(self)




    def reconciliation_check_header(self):

        localctx = SodaCLAntlrParser.Reconciliation_check_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_reconciliation_check_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 456
            self.match(SodaCLAntlrParser.T__22)
            self.state = 457
            self.match(SodaCLAntlrParser.S)
            self.state = 458
            self.identifier()
            self.state = 459
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.NumberContext,0)


        def PLUS(self):
            return self.getToken(SodaCLAntlrParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SodaCLAntlrParser.MINUS, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_signed_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_number" ):
                listener.enterSigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_number" ):
                listener.exitSigned_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_number" ):
                return visitor.visitSigned_number(self)
            else:
                return visitor.visitChildren(self)




    def signed_number(self):

        localctx = SodaCLAntlrParser.Signed_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_signed_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==46 or _la==47:
                self.state = 461
                _la = self._input.LA(1)
                if not(_la==46 or _la==47):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 464
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IntegerContext,0)


        def DIGITS(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.DIGITS)
            else:
                return self.getToken(SodaCLAntlrParser.DIGITS, i)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = SodaCLAntlrParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.state = 477
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 466
                self.integer()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 467
                self.match(SodaCLAntlrParser.DIGITS)
                self.state = 468
                self.match(SodaCLAntlrParser.T__23)
                self.state = 470
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==60:
                    self.state = 469
                    self.match(SodaCLAntlrParser.DIGITS)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 473
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==60:
                    self.state = 472
                    self.match(SodaCLAntlrParser.DIGITS)


                self.state = 475
                self.match(SodaCLAntlrParser.T__23)
                self.state = 476
                self.match(SodaCLAntlrParser.DIGITS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGITS(self):
            return self.getToken(SodaCLAntlrParser.DIGITS, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteger" ):
                listener.enterInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteger" ):
                listener.exitInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteger" ):
                return visitor.visitInteger(self)
            else:
                return visitor.visitChildren(self)




    def integer(self):

        localctx = SodaCLAntlrParser.IntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_integer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.match(SodaCLAntlrParser.DIGITS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER_UNQUOTED(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_UNQUOTED, 0)

        def IDENTIFIER_DOUBLE_QUOTE(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_DOUBLE_QUOTE, 0)

        def IDENTIFIER_BACKTICK(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_BACKTICK, 0)

        def IDENTIFIER_SQUARE_BRACKETS(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_SQUARE_BRACKETS, 0)

        def MIN(self):
            return self.getToken(SodaCLAntlrParser.MIN, 0)

        def MAX(self):
            return self.getToken(SodaCLAntlrParser.MAX, 0)

        def AVG(self):
            return self.getToken(SodaCLAntlrParser.AVG, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = SodaCLAntlrParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 481
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 540432195802628096) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





