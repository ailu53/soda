from __future__ import annotations

from soda.execution.check.check import Check
from soda.execution.check_outcome import CheckOutcome
from soda.execution.metric.metric import Metric
from soda.execution.metric.reconciliation_row_count_metric import (
    ReconciliationRowCountMetric,
)
from soda.execution.table import Table
from soda.sodacl.reconciliation_row_diff_check_cfg import ReconciliationRowDiffCheckCfg


class ReconciliationRowDiffCheck(Check):
    ADDED = "added"
    CHANGED = "changed"
    REMOVED = "removed"
    METADATA = "metadata"
    COLUMNS = "columns"

    def __init__(
        self, check_cfg: ReconciliationRowDiffCheckCfg, data_source_scan: DataSourceScan, partition: Partition
    ):
        super().__init__(check_cfg=check_cfg, data_source_scan=data_source_scan, partition=partition, column=None)

        self.logs.debug(f"Using '{self.check_cfg.strategy}' strategy for reconciliation check '{self.name}'.")

        self.check_cfg = check_cfg
        self.data_source_scan = data_source_scan
        self.partition = partition

        scan = data_source_scan.scan

        source_config = check_cfg.reconciliation_configurations["source"]
        target_config = check_cfg.reconciliation_configurations["target"]
        self.source_key_columns = check_cfg.source_key_columns
        self.target_key_columns = check_cfg.target_key_columns

        self.source_data_source_scan = scan._get_or_create_data_source_scan(source_config["datasource"])
        self.source_table: Table = self.source_data_source_scan.get_or_create_table(source_config["dataset"])
        self.source_partition = self.source_table.get_or_create_partition(None)
        self.source_filter = source_config.get("filter")

        self.target_data_source_scan = scan._get_or_create_data_source_scan(target_config["datasource"])
        self.target_table: Table = self.target_data_source_scan.get_or_create_table(target_config["dataset"])
        self.target_partition = self.target_table.get_or_create_partition(None)
        self.target_filter = target_config.get("filter")

        self.diff_config = check_cfg.diff_config

        self.metrics = {}

        src_columns = "*"
        if check_cfg.source_columns:
            src_columns = check_cfg.source_columns

            for src_key_column in check_cfg.source_key_columns:
                if src_key_column not in src_columns:
                    src_columns.append(src_key_column)
        self.src_columns = src_columns

        tgt_columns = "*"
        if check_cfg.target_columns:
            tgt_columns = check_cfg.target_columns

            for tgt_key_column in check_cfg.target_key_columns:
                if tgt_key_column not in tgt_columns:
                    tgt_columns.append(tgt_key_column)
        self.tgt_columns = tgt_columns

        self.outcome_dict = {}

    def evaluate(self, metrics: dict[str, Metric], historic_values: dict[str, object]):
        pass

    def get_log_diagnostic_dict(self) -> dict:
        d = super().get_log_diagnostic_dict()

        d["source_count"] = self.outcome_dict.get("source_count")
        d["target_count"] = self.outcome_dict.get("target_count")
        d["changed"] = self.outcome_dict.get("changed")
        d["exclusive_in_target"] = self.outcome_dict.get("exclusive_in_target")
        d["exclusive_in_source"] = self.outcome_dict.get("exclusive_in_source")

        return d

    def get_cloud_diagnostics_dict(self) -> dict:
        cloud_diagnostics = super().get_cloud_diagnostics_dict()

        diagnostic_text = ""
        for key, value in self.outcome_dict.items():
            diagnostic_text += f"{key.replace('_', ' ').title()}, {value}\n"

        diagnostics_block = {
            "type": "csv",
            "title": "Diagnostics",
            "text": f"Event, Value\n{diagnostic_text}",
        }
        cloud_diagnostics["blocks"].append(diagnostics_block)

        return cloud_diagnostics

    def set_outcome_based_on_check_value(self):
        reconciliation_check_cfg = self.check_cfg
        if self.check_value is not None and reconciliation_check_cfg.has_threshold():
            reconciliation_check_cfg.resolve_thresholds(self.data_source_scan.scan.jinja_resolve)
            if reconciliation_check_cfg.fail_threshold_cfg and reconciliation_check_cfg.fail_threshold_cfg.is_bad(
                self.check_value
            ):
                self.outcome = CheckOutcome.FAIL
            elif reconciliation_check_cfg.warn_threshold_cfg and reconciliation_check_cfg.warn_threshold_cfg.is_bad(
                self.check_value
            ):
                self.outcome = CheckOutcome.WARN
            else:
                self.outcome = CheckOutcome.PASS

    def get_cloud_dict(self):
        d = super().get_cloud_dict()

        if "dataSource" in d:
            del d["dataSource"]

        if "table" in d:
            del d["table"]

        d["dataSources"] = [
            {
                "dataSource": self.check_cfg.reconciliation_configurations["source"]["datasource"],
                "table": self.check_cfg.reconciliation_configurations["source"]["dataset"],
                "qualifier": "source",
            },
            {
                "dataSource": self.check_cfg.reconciliation_configurations["target"]["datasource"],
                "table": self.check_cfg.reconciliation_configurations["target"]["dataset"],
                "qualifier": "target",
            },
        ]

        d["group"] = {
            "identity": self.check_cfg.reconciliation_configurations["group_identity"],
            "name": self.check_cfg.reconciliation_configurations["label"],
            "distinctLabel": self.name,
            "type": "reconciliation",
        }

        return d

    def identity_datasource_part(self) -> list[str]:
        return [
            self.check_cfg.reconciliation_configurations["source"]["datasource"],
            self.check_cfg.reconciliation_configurations["source"]["dataset"],
            self.check_cfg.reconciliation_configurations["target"]["datasource"],
            self.check_cfg.reconciliation_configurations["target"]["dataset"],
        ]

    def add_to_samples(self, samples: list, row: list):
        limit = 100
        if self.check_cfg.samples_limit:
            limit = self.check_cfg.samples_limit

        if len(samples) < limit:
            samples.append(row)
