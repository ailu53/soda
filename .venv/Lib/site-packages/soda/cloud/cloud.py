from __future__ import annotations

import logging
import math
import re
from abc import ABC
from typing import TYPE_CHECKING

import requests
from requests import Response
from requests.auth import HTTPBasicAuth
from soda_library.__version__ import SODA_LIBRARY_VERSION

from soda.cloud.historic_descriptor import HistoricDescriptor
from soda.common.json_helper import JsonHelper
from soda.common.logs import Logs

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from soda.scan import Scan


class Cloud(ABC):
    CSV_TEXT_MAX_LENGTH = math.inf

    def __init__(
        self,
        host: str,
        api_key_id: str,
        api_key_secret: str,
        token: str | None,
        port: str | None,
        logs: Logs,
        scheme: str = "https",
    ):
        # TODO: revisit if this is generic enough to be in core.
        self.host = host
        self.port = f":{port}" if port else ""
        self.scheme = scheme if scheme else "https"
        self.api_url = f"{self.scheme}://{self.host}{self.port}/api"
        self.api_key_id = api_key_id
        self.api_key_secret = api_key_secret
        self.token: str | None = token
        self.headers = {"User-Agent": f"SodaLibrary/{SODA_LIBRARY_VERSION}"}
        self.logs = logs
        self._organization_configuration = None

    @property
    def organization_configuration(self) -> dict:
        return self._organization_configuration

    @staticmethod
    def build_scan_results(scan, metadata: dict = {}) -> dict:
        checks = [
            check.get_dict()
            for check in scan._checks
            if (check.outcome is not None or check.force_send_results_to_cloud is True) and check.archetype is None
        ]
        automated_monitoring_checks = [
            check.get_dict()
            for check in scan._checks
            if (check.outcome is not None or check.force_send_results_to_cloud is True) and check.archetype is not None
        ]

        profiling = [
            profile_table.get_dict()
            for profile_table in scan._profile_columns_result_tables + scan._sample_tables_result_tables
        ]

        query_list = []
        for query in scan._queries:
            query_list += query.get_dicts()

        return JsonHelper.to_jsonnable(  # type: ignore
            {
                "definitionName": scan._scan_definition_name,
                "defaultDataSource": scan._data_source_name,
                "dataTimestamp": scan._data_timestamp,
                # Can be changed by user, this is shown in Cloud as time of a scan.
                "scanStartTimestamp": scan._scan_start_timestamp,  # Actual time when the scan started.
                "scanEndTimestamp": scan._scan_end_timestamp,  # Actual time when scan ended.
                "hasErrors": scan.has_error_logs(),
                "hasWarnings": scan.has_check_warns(),
                "hasFailures": scan.has_check_fails(),
                "metrics": [metric.get_cloud_dict() for metric in scan._metrics],
                # If archetype is not None, it means that check is automated monitoring
                "checks": checks,
                "queries": query_list,
                "automatedMonitoringChecks": automated_monitoring_checks,
                "profiling": profiling,
                "metadata": [
                    discover_tables_result.get_cloud_dict()
                    for discover_tables_result in scan._discover_tables_result_tables
                ],
                "logs": [log.get_dict() for log in scan._logs.logs],
            }
        )

    @staticmethod
    def _serialize_file_upload_value(value):
        if value is None or isinstance(value, str) or isinstance(value, int) or isinstance(value, float):
            return value
        return str(value)

    def upload_sample(
        self, scan: Scan, sample_rows: tuple[tuple], sample_file_name: str, samples_limit: int | None
    ) -> str:
        raise NotImplementedError()

    def _fileify(self, name: str):
        return re.sub(r"\W+", "_", name).lower()

    def get_historic_data(self, historic_descriptor: HistoricDescriptor):
        raise NotImplementedError()

    def is_samples_disabled(self) -> bool:
        return False

    def _execute_query(self, query: dict, query_name: str):
        _, json = self._execute_request(path="query", request_body=query, request_name=query_name)

        return json

    def _execute_command(self, command: dict, command_name: str):
        _, json = self._execute_request(path="command", request_body=command, request_name=command_name)

        return json

    def _execute_rest_get(
        self,
        path: str,
        request_name: str,
        request_body: dict | None = None,
        request_data: dict | None = None,
        auth_method: str | None = "token",
    ):
        return self._execute_request(
            path=path,
            request_name=request_name,
            request_body=request_body,
            request_data=request_data,
            request_type="GET",
            auth_method=auth_method,
        )

    def _execute_rest_post(
        self,
        path: str,
        request_name: str,
        request_body: dict | None = None,
        request_data: dict | None = None,
        auth_method: str | None = "token",
    ):
        return self._execute_request(
            path=path,
            request_name=request_name,
            request_body=request_body,
            request_data=request_data,
            request_type="POST",
            auth_method=auth_method,
        )

    def _execute_request(
        self,
        path: str,
        request_name: str,
        request_body: dict | None = None,
        request_data: dict | None = None,
        is_retry: bool = False,
        request_type: str = "POST",
        auth_method: str = "token",
        is_path_absolute: bool = False,
    ) -> tuple[Response, dict] | None:
        """Returns a tuple with the response and the response json."""
        from soda.scan import verbose

        return_value = None

        try:
            auth = None
            if auth_method == "token":
                request_body["token"] = self._get_token()
            elif auth_method == "basic":
                auth = HTTPBasicAuth(self.api_key_id, self.api_key_secret)
            else:
                raise ValueError(f"Unsupported auth method: {auth_method}")

            if verbose:
                if request_body:
                    logger.debug(f"{JsonHelper.to_json_pretty(request_body)}")
                if request_data:
                    logger.debug(f"{JsonHelper.to_json_pretty(request_data)}")

            if request_type == "GET":
                request_method = self._http_get
            elif request_type == "POST":
                request_method = self._http_post
            elif request_type == "DELETE":
                request_method = self._http_delete
            else:
                raise ValueError(f"Unsupported request type: {request_type}")

            full_path = f"{self.api_url}/{path}"
            if is_path_absolute:
                full_path = path

            request_args = {
                "url": full_path,
                "headers": self.headers,
                "json": request_body,
                "request_name": request_name,
                "data": request_data,
            }
            if auth:
                request_args["auth"] = auth

            response = request_method(**request_args)

            if response.headers.get("content-type") == "application/json":
                return_value = (response, response.json())
            else:
                return_value = (response, response.content)

            if response.status_code == 401 and not is_retry:
                if auth_method == "token":  # Retry only makes sense for token based auth
                    logger.debug("Authentication failed. Probably token expired. Re-authenticating...")
                    self.token = None
                    return_value = self._execute_request(
                        path=path,
                        request_name=request_name,
                        request_body=request_body,
                        request_data=request_data,
                        is_retry=True,
                        request_type=request_type,
                        auth_method=auth_method,
                    )
                else:
                    logger.debug("Authentication failed. Please check your credentials.")
            elif not response.ok:
                self.logs.error(f"Error while executing Soda Cloud '{path}' response code: {response.status_code}")
                if verbose:
                    self.logs.debug(response.text)
                return (response, None)  # No need to return anything if the request failed - error is already logged.
            return return_value
        except Exception as e:
            self.logs.error(f"Error while executing Soda Cloud {path}", exception=e)

    def _http_post(self, request_name: str = None, **kwargs) -> Response:
        response = requests.post(**kwargs)

        if request_name:
            trace_id = response.headers.get("X-Soda-Trace-Id")
            if trace_id:
                self.soda_cloud_trace_ids[request_name] = trace_id

        return response

    def _http_get(self, request_name: str = None, **kwargs) -> Response:
        response = requests.get(**kwargs)

        if request_name:
            trace_id = response.headers.get("X-Soda-Trace-Id")
            if trace_id:
                self.soda_cloud_trace_ids[request_name] = trace_id

        return response

    def _http_delete(self, request_name: str = None, **kwargs) -> Response:
        response = requests.delete(**kwargs)

        if request_name:
            trace_id = response.headers.get("X-Soda-Trace-Id")
            if trace_id:
                self.soda_cloud_trace_ids[request_name] = trace_id

        return response

    def _get_token(self):
        raise NotImplementedError()
